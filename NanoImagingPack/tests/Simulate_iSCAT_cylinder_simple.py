# -*- coding: utf-8 -*-
"""

generate iSCAT image of subwavelength particles
a cylindrical lens is in the optical system in order to do 3D localisation 

@author: rheintzmann, stranik
"""
import NanoImagingPack as nip
import numpy as np
from NanoImagingPack import v5


def cylindricallens(para, **kwargs):
    ''' add cylindrical lens to the optical system 
     
    TODO: relation between position, focal length of the lens and abberation strength
    '''
    mypara = para
    mypara.aberration_strength = 0.5
    mypara.aberration_types = 'astigm' 
    return mypara

def particlestrength(epm=1.33**2, epp=1.5**2, D=100, phi_gouy=0):
    ''' calculte the amplitude and phase of the spherical wave generated by particle (dipole appr.)
    
    parameters:
        epm: epsilon of medium
        epp: epsilon of particle
        D: diameter of particle in [nm]
        ?phi_gouy ... phase shift generated by the focusing (perfect focus = pi/2) ?
    return:
        scattering amplitude
   
    TODO : bind from analytial (Mie) solution
    '''
    D = D/1e9 # in SI units [m]
    # s .. dipole 
    s = epm*np.pi*D**3/2*(epp - epm)/(epp + 2*epm)
    
    s = 1e-6
    #s = 5e-6*np.exp(1.4*1j)
    s = s*np.exp(phi_gouy*1j)
    
    return s


def phasemask(im, transmission=1 * np.exp(1j), size=4):
    ''' transmission mask for the reflected wave to adjust its phase and amplitude

    Introduce a phase mask, which allows to enhance the sensitivity.
    Dim down the mirror reflection but leave the particle scattering mostly unaffected
    '''
    myim = (im[0]*0.0 + 0j) + 1
    mymask = nip.rr(myim) < size
    myim[mymask] *= transmission
    return myim


def localisation3D():
    ''' shows iSCAT image of two particles with cylindrical lens in the optical path 
    in order to carry out 3D localistion '''
    
    # set the imaging parameters
    para = nip.PSF_PARAMS()  # obtain a default set of PSF parameters
    # set the water above the cover slip
    para.n_embedding = 1.33
    #para.n_embedding = para.n

    # transmission and reflection coefficients
    r = (para.n - para.n_embedding)/(para.n + para.n_embedding)
    t = 1 - r
    
    # create the pattern
    # myphaseim = im[0]*0.0 + 0j
    #s = particlestrength(epm= para.n_embedding**2, epp=(-9.38 + 1.5j), D=200, phi_gouy=0)
    s1 = particlestrength(phi_gouy=0)
    s2 = particlestrength(phi_gouy=np.pi/2)

    # myphaseim += addparticle(im, 0, 1000,t*s1)
    # myphaseim += addparticle(im, 0,-1000,t*s2)
    # myphaseim += addreflectedwave(im, r = r)

    # para.pol = [myphaseim, myphaseim*0] # replace the pupil with a well designed structure of polarized emission
    para.pol = 'lin_x' # replace the pupil with a well designed structure of polarized emission

    # add cylindrical lens
    para = cylindricallens(para)

    # im = nip.readim('obj3d')  # load an example object. Only to have a pixelsize and image size
    sz =[128,128,128]
    pixelsize = [30.0, 100.0, 100.0]
    obj = nip.zeros(sz,pixelsize=pixelsize)
    obj[64,50,64] = 1
    obj[72,70,64] = 1
    excitation = np.exp(-1j * 2*np.pi/para.wavelength*para.n_embedding * nip.zz(obj) * obj.pixelsize[0]) # planeWave(para, orientation)
    excitation = np.stack((excitation,0*excitation,0*excitation))

    apsf = nip.apsf(obj, para)  # simulate the psf, i.e. the image
    reference = np.array([2.0,0,0]); reference = reference[:,np.newaxis,np.newaxis,np.newaxis]
    imgAmp = nip.convolve(obj * excitation, apsf, axes=[1,2,3]) + reference

    pimg = np.sum(nip.abssqr(imgAmp), 0)

    NPhotons = 1e6  # number of photons per pixel in the brightes pixel
    nimg = nip.noise.poisson(pimg, NPhot=NPhotons) # apply poisson noise
    v5(nip.catE(pimg,nimg))  # visualize the result

def main():
    nip.setDefault('IMG_VIEWER','VIEW5D') # if Java is installed correctly
    localisation3D()


# call main()
if __name__ == "__main__":
    main()    
    
    
